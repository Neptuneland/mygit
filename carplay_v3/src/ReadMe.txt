

/***********************************************
*
* Project: 智能小车项目
* Author: 邹鹏
* Date: 2018.11.20
* Institute: NJUST
* E-mail: dongnanzdhzp@163.com
*
************************************************/

0、避障不是主要的，跟点走才是主要的


1、运行时，carplay.cpp里的读取gps点的txt绝对路径要适当修改。

2、测试惯导传回的地面坐标值与通过函数转GPS的地球坐标是否一致，不一致的话在回调函数那里加上偏移量。打印消息检查

3、ros::spinOnce会同时回传两个消息吗？

4、所有串口发送控制指令后面都要接睡眠200毫秒函数，注意，检查

5、前进过程中注意检测偏航角

6、老蔡说能跟点走就行，不需要避障的话就不避障了，gps文件自己做。跟点走间隔可以自己设一个合理的值

7、最终到达终点的判断条件是什么？？绕一圈的话->终点等于起点，然后停止？？还是设固定数目，比如跟点走了200个点，然后停止

8、需要加入紧急情况刹车

9、GPS.txt里面 第一个经度，第二个纬度。  偏移量怎么加？





/********************************************
*
* 1123下午调试记录
*
* 1、
*
*
*
*********************************************/












/****************************************************************************************************
         * 跟点走算法思想
         *
         * 流程：
         * 1、读文件，获取下一个要到达的目标点的GPS，然后函数转换成地球坐标
         * 2、计算让车头正对目标点的偏航角，转弯，直到惯导返回的偏航角与需要值之差在允许误差范围（弧度0.05,角度2度左右）内
         * 3、检测栅格地图的前方有效范围，即前方10米内是否有障碍，有的话，先管小车前方最近的障碍，在旁边找需要经过的点，
         * 然后栅格坐标到地球坐标换算，将下一个需要到达的目标点替换为这个坐标点。
         * 4、检测小车与目标点的地球坐标之间距离是否小于允许误差，小于则读入下一个目标点，进入循环
         *
         *      转弯到达目标点是不是要写一个函数？？
         *
         *
         * Note：算法结构示意：
         *          int i = 0;
         *          while(1)
         *          {
         *              读入第i个目标点，赋值为dest[i];  //dest[i][0]=X, dest[i][1]=Y
         *              while(1)
         *              {
         *                  while(1)
         *                  {
         *
         *                      if(偏航角等于两坐标点连线与Y轴夹角)
         *                          break;
         *                      转弯;  //放后面，合适
         *                  }
         *
         *
         *                  检查前方障碍物;
         *                  if(有障碍物)//前进到障碍物旁边点，然后continue
         *                  {
         *                     if(石头型障碍)
         *                      {
         *                          调函数，get下一个要走的目标点destTem;
         *                      }
         *                     if(墙型障碍)
         *                      {
         *                          转弯，直到变成石头型障碍，然后调函数找到经过点;
         *                      }
         *
         *                      //下面是不考虑障碍版的跟点走算法，包括转弯对准目标点和执行直到目标点两部分
         *                      //目的是走到障碍旁边点
         *                      while(1)
         *                      {
         *                          while(1)
         *                              {
         *                              转弯，对准障碍旁边点;
         *                              if(对准)
         *                                  break;
         *                              }
         *                          while(1)
         *                              {
         *                              前进;
         *                              if(到达障碍旁边点)
         *                                  isDestObs = true;
         *                                  break;
         *                              }
         *
         *                          if(isDestObs)
         *                              break;
         *                      }
         *                      if(isDestObs)
         *                          continue;
         *
         *
         *                  }
         *
         *                   while(1)
         *                  {
         *                      前进; //前进同时检查角度，角度不对的话，及时调整角度对准;另外，如前方出现障碍物，
         *                          //跳转到检查到炸障碍物的函数那里
         *                      计算当前应该保持的偏航角;
         *                      if(当前角度！=应该保持的角度)
         *                          break;
         *                      if(前方有障碍)
         *                          break;
         *                      if(到达目标点)
         *                          isDest = true;
         *                          break;
         *                  }
         *
         *                  //跳出次大循环唯一条件，到达读入的第i个目标点
         *                  if(isDest == true)
         *                  i++;
         *                  break;
         *              }
         *
         *              if(到达最终终点)
         *                  break;
         *                  printf("Successful Arrival");
         *
         *          }
         *
         *
         * 需考虑的情况：
         *      1、一开始没有障碍物，走了一段路后前方又出现了障碍物
         *
         *
         *
         *
         ***************************************************************************************************/





